import numpy as np
from scipy.spatial import Voronoi
from typing import List, Dict
import random

from games.walk_and_key.room_and_door import Room, Door
from games.walk_and_key.graph import Graph


def get_voronoi_graph(num_rooms: int, bounding_box_size: int = 100) -> Graph:
    world = Graph()

    # Generate random points for Voronoi diagram
    points = np.random.rand(num_rooms, 2) * bounding_box_size

    # Compute Voronoi diagram
    vor = Voronoi(points)

    # Create rooms based on Voronoi regions
    rooms: Dict[int, Room] = {}
    for i, (x, y) in enumerate(vor.points):
        room_name = f"Room {i + 1}"
        room_type = "generic"
        size = random.randint(1, 10)  # Random size between 1 and 10
        adjectives = ["voronoi"]  # You can add more random adjectives here
        description = f"A room generated by Voronoi diagram at ({x:.2f}, {y:.2f})"

        room = Room(room_name, room_type, size, adjectives, description, x=int(x), y=int(y))
        world.add_room(room)
        rooms[i] = room

    # Set the first room as the starting room
    if world.rooms:
        world.starting_room = world.rooms[0]

    # Create connections based on Voronoi neighbors
    directions = ["north", "south", "east", "west"]
    for i, neighbors in enumerate(vor.ridge_points):
        room1, room2 = rooms[neighbors[0]], rooms[neighbors[1]]
        direction = get_direction(room1, room2)
        opposite_direction = get_opposite_direction(direction)

        # Add bidirectional doors
        world.add_door(room1, room2, direction)
        world.add_door(room2, room1, opposite_direction)

    return world


def get_direction(room1: Room, room2: Room) -> str:
    dx = room2.x - room1.x
    dy = room2.y - room1.y

    if abs(dx) > abs(dy):
        return "east" if dx > 0 else "west"
    else:
        return "north" if dy > 0 else "south"


def get_opposite_direction(direction: str) -> str:
    opposites = {"north": "south", "south": "north", "east": "west", "west": "east"}
    return opposites[direction]